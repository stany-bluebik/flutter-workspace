"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleNxReleaseConfigError = exports.createNxReleaseConfig = exports.CATCH_ALL_RELEASE_GROUP = void 0;
const devkit_exports_1 = require("../../../devkit-exports");
const find_matching_projects_1 = require("../../../utils/find-matching-projects");
const project_graph_utils_1 = require("../../../utils/project-graph-utils");
const resolve_nx_json_error_message_1 = require("../utils/resolve-nx-json-error-message");
exports.CATCH_ALL_RELEASE_GROUP = '__default__';
// Apply default configuration to any optional user configuration and handle known errors
async function createNxReleaseConfig(projectGraph, userConfig = {}, 
// Optionally ensure that all configured projects have implemented a certain target
requiredTargetName) {
    const DEFAULT_VERSION_GENERATOR = '@nx/js:release-version';
    const DEFAULT_VERSION_GENERATOR_OPTIONS = {};
    const allProjects = (0, find_matching_projects_1.findMatchingProjects)(['*'], projectGraph.nodes);
    const userSpecifiedGroups = userConfig.groups || {};
    /**
     * No user specified release groups, so we treat all projects as being in one release group
     * together in which all projects are released in lock step.
     */
    if (Object.keys(userSpecifiedGroups).length === 0) {
        // Ensure all projects have the relevant target available, if applicable
        if (requiredTargetName) {
            const error = ensureProjectsHaveTarget(allProjects, projectGraph, requiredTargetName);
            if (error) {
                return {
                    error,
                    nxReleaseConfig: null,
                };
            }
        }
        return {
            error: null,
            nxReleaseConfig: {
                groups: {
                    [exports.CATCH_ALL_RELEASE_GROUP]: {
                        projects: allProjects,
                        version: {
                            generator: DEFAULT_VERSION_GENERATOR,
                            generatorOptions: DEFAULT_VERSION_GENERATOR_OPTIONS,
                        },
                    },
                },
            },
        };
    }
    /**
     * The user has specified at least one release group.
     *
     * Resolve all the project names into their release groups, and check
     * that individual projects are not found in multiple groups.
     */
    const releaseGroups = {};
    const alreadyMatchedProjects = new Set();
    for (const [releaseGroupName, userSpecifiedGroup] of Object.entries(userSpecifiedGroups)) {
        // Ensure that the user config for the release group can resolve at least one project
        const matchingProjects = (0, find_matching_projects_1.findMatchingProjects)(Array.isArray(userSpecifiedGroup.projects)
            ? userSpecifiedGroup.projects
            : [userSpecifiedGroup.projects], projectGraph.nodes);
        if (!matchingProjects.length) {
            return {
                error: {
                    code: 'RELEASE_GROUP_MATCHES_NO_PROJECTS',
                    data: {
                        releaseGroupName: releaseGroupName,
                    },
                },
                nxReleaseConfig: null,
            };
        }
        // Ensure all matching projects have the relevant target available, if applicable
        if (requiredTargetName) {
            const error = ensureProjectsHaveTarget(matchingProjects, projectGraph, requiredTargetName);
            if (error) {
                return {
                    error,
                    nxReleaseConfig: null,
                };
            }
        }
        for (const project of matchingProjects) {
            if (alreadyMatchedProjects.has(project)) {
                return {
                    error: {
                        code: 'PROJECT_MATCHES_MULTIPLE_GROUPS',
                        data: {
                            project,
                        },
                    },
                    nxReleaseConfig: null,
                };
            }
            alreadyMatchedProjects.add(project);
        }
        releaseGroups[releaseGroupName] = {
            projects: matchingProjects,
            version: userSpecifiedGroup.version
                ? {
                    generator: userSpecifiedGroup.version.generator || DEFAULT_VERSION_GENERATOR,
                    generatorOptions: userSpecifiedGroup.version.generatorOptions ||
                        DEFAULT_VERSION_GENERATOR_OPTIONS,
                }
                : {
                    generator: DEFAULT_VERSION_GENERATOR,
                    generatorOptions: DEFAULT_VERSION_GENERATOR_OPTIONS,
                },
        };
    }
    return {
        error: null,
        nxReleaseConfig: {
            ...userConfig,
            groups: releaseGroups,
        },
    };
}
exports.createNxReleaseConfig = createNxReleaseConfig;
async function handleNxReleaseConfigError(error) {
    switch (error.code) {
        case 'RELEASE_GROUP_MATCHES_NO_PROJECTS':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'groups',
                ]);
                devkit_exports_1.output.error({
                    title: `Release group "${error.data.releaseGroupName}" matches no projects. Please ensure all release groups match at least one project:`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'PROJECT_MATCHES_MULTIPLE_GROUPS':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'groups',
                ]);
                devkit_exports_1.output.error({
                    title: `Project "${error.data.project}" matches multiple release groups. Please ensure all projects are part of only one release group:`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'PROJECTS_MISSING_TARGET':
            {
                devkit_exports_1.output.error({
                    title: `Based on your config, the following projects were matched for release but do not have a "${error.data.targetName}" target specified. Please ensure you have an appropriate plugin such as @nx/js installed, or have configured the target manually, or exclude the projects using release groups config in nx.json:`,
                    bodyLines: Array.from(error.data.projects).map((name) => `- ${name}`),
                });
            }
            break;
        default:
            throw new Error(`Unhandled error code: ${error.code}`);
    }
    process.exit(1);
}
exports.handleNxReleaseConfigError = handleNxReleaseConfigError;
function ensureProjectsHaveTarget(projects, projectGraph, requiredTargetName) {
    const missingTargetProjects = projects.filter((project) => !(0, project_graph_utils_1.projectHasTarget)(projectGraph.nodes[project], requiredTargetName));
    if (missingTargetProjects.length) {
        return {
            code: 'PROJECTS_MISSING_TARGET',
            data: {
                targetName: requiredTargetName,
                projects: missingTargetProjects,
            },
        };
    }
    return null;
}
